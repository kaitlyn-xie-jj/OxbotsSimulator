<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Field Viewer</title>
    <style>
      :root {
        --bg: #f3f0e7;
        --bg-2: #e7ecef;
        --ink: #1f1f1f;
        --accent: #e4572e;
        --accent-2: #1d7d7a;
        --muted: #7a7a7a;
        --visible: #00DF6C;
        --steel: #6c757d;
        --ping: #3d5a80;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family: "IBM Plex Sans", "Helvetica Neue", Arial, sans-serif;
        color: var(--ink);
        background: radial-gradient(circle at 20% 20%, var(--bg), var(--bg-2));
        min-height: 100vh;
        display: grid;
        place-items: center;
      }
      .wrap {
        width: min(1100px, 96vw);
        display: grid;
        grid-template-columns: 1fr 320px;
        gap: 20px;
      }
      .panel {
        background: rgba(255, 255, 255, 0.65);
        border: 1px solid rgba(0, 0, 0, 0.08);
        border-radius: 16px;
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.08);
        backdrop-filter: blur(6px);
      }
      .canvas-panel {
        padding: 16px;
      }
      .hud {
        padding: 18px 16px;
      }
      h1 {
        margin: 0 0 10px 0;
        font-size: 22px;
        letter-spacing: 0.4px;
      }
      .stat {
        font-size: 13px;
        color: var(--muted);
        margin: 8px 0;
      }
      .legend {
        margin-top: 14px;
        font-size: 13px;
      }
      .legend div {
        display: flex;
        align-items: center;
        gap: 8px;
        margin: 6px 0;
      }
      .chip {
        width: 14px;
        height: 14px;
        border-radius: 4px;
      }
      canvas {
        width: 100%;
        aspect-ratio: 1 / 1;
        display: block;
        border-radius: 12px;
        background:
          linear-gradient(90deg, rgba(0,0,0,0.04) 1px, transparent 1px),
          linear-gradient(0deg, rgba(0,0,0,0.04) 1px, transparent 1px);
        background-size: 10% 10%;
      }
      .note {
        margin-top: 12px;
        font-size: 12px;
        color: var(--muted);
      }
      .around-wrap {
        margin-top: 18px;
        display: grid;
        justify-items: center;
      }
      .around-title {
        margin-top: 6px;
        font-size: 12px;
        color: var(--muted);
        letter-spacing: 0.3px;
        text-transform: uppercase;
      }
      #around {
        width: 100%;
        max-width: 220px;
        aspect-ratio: 1 / 1;
        border: 2px solid rgba(31, 31, 31, 0.5);
        border-radius: 10px;
        background: rgba(255, 255, 255, 0.5);
      }
      @media (max-width: 900px) {
        .wrap {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="panel canvas-panel">
        <canvas id="field" width="800" height="800"></canvas>
      </div>
      <div class="panel hud">
        <h1>Field Viewer</h1>
        <div class="stat" id="robotStat">Robot: --</div>
        <div class="stat" id="ballStat">Balls: --</div>
        <div class="stat" id="visibleStat">Visible: --</div>
        <div class="stat" id="obsStat">Obstacles: --</div>
        <div class="legend">
          <div><span class="chip" style="background: var(--accent)"></span> Robot</div>
          <div><span class="chip" style="background: var(--accent-2)"></span> Robot Front</div>
          <div><span class="chip" style="background: var(--ping)"></span> Ping</div>
          <div><span class="chip" style="background: var(--steel)"></span> Steel</div>
          <div><span class="chip" style="background: var(--visible)"></span> Visible Highlight</div>
        </div>
        <div class="note">Range: x,y in [-1, 1] meters</div>
        <div class="around-wrap">
          <canvas id="around" width="220" height="220"></canvas>
          <div class="around-title">robot around</div>
        </div>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("field");
      const ctx = canvas.getContext("2d");
      const aroundCanvas = document.getElementById("around");
      const aroundCtx = aroundCanvas.getContext("2d");

      const robotStat = document.getElementById("robotStat");
      const ballStat = document.getElementById("ballStat");
      const visibleStat = document.getElementById("visibleStat");
      const obsStat = document.getElementById("obsStat");

      const COLORS = {
        robot: "#e4572e",
        robotFront: "#1d7d7a",
        ping: "#3d5a80",
        steel: "#6c757d",
        visible: "#00DF6C",
        obstacle: "#212529",
        dynamic: "#e4572e",
        stack: "#1d7d7a",
        waypointLine: "rgba(0, 0, 0, 0.35)",
        waypointMuted: "#7a7a7a",
        aroundBox: "rgba(31, 31, 31, 0.5)",
        aroundVector: "#1d7d7a",
        aroundCenter: "#1f1f1f"
      };

      function worldToCanvas(x, y) {
        const size = canvas.width;
        const px = ((x + 1) / 2) * size;
        const py = size - ((y + 1) / 2) * size;
        return [px, py];
      }

      function drawField() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        ctx.strokeStyle = "rgba(0,0,0,0.6)";
        ctx.lineWidth = 2;
        ctx.strokeRect(0, 0, canvas.width, canvas.height);
        ctx.restore();
      }

      function drawRobot(x, y, bearingDeg) {
        const [px, py] = worldToCanvas(x, y);
        const size = canvas.width * 0.1; // 0.2m in a 2m field
        const half = size / 2;
        const angle = (bearingDeg || 0) * Math.PI / 180.0;

        ctx.save();
        ctx.translate(px, py);
        ctx.rotate(-angle);
        ctx.fillStyle = COLORS.robot;
        ctx.fillRect(-half, -half, size, size);

        ctx.fillStyle = COLORS.robotFront;
        ctx.fillRect(0, -half, half, size);

        ctx.restore();
      }

      function drawObstacle(x, y, bearingDeg) {
        const [px, py] = worldToCanvas(x, y);
        const size = canvas.width * 0.1; // 0.2m in a 2m field
        const half = size / 2;
        const angle = (bearingDeg || 0) * Math.PI / 180.0;

        ctx.save();
        ctx.translate(px, py);
        ctx.rotate(-angle);
        ctx.fillStyle = COLORS.obstacle;
        ctx.globalAlpha = 0.85;
        ctx.fillRect(-half, -half, size, size);
        ctx.restore();
      }

      function drawBall(x, y, typ, highlight) {
        const [px, py] = worldToCanvas(x, y);
        const r = canvas.width * 0.012;
        ctx.save();
        ctx.beginPath();
        ctx.arc(px, py, r, 0, Math.PI * 2);
        ctx.fillStyle = typ === "STEEL" ? COLORS.steel : COLORS.ping;
        ctx.fill();

        if (highlight) {
          ctx.strokeStyle = COLORS.visible;
          ctx.lineWidth = 3;
          ctx.stroke();
        }
        ctx.restore();
      }

      function drawLine(x1, y1, x2, y2, color, width) {
        const [p1x, p1y] = worldToCanvas(x1, y1);
        const [p2x, p2y] = worldToCanvas(x2, y2);
        ctx.save();
        ctx.strokeStyle = color;
        ctx.lineWidth = width;
        ctx.beginPath();
        ctx.moveTo(p1x, p1y);
        ctx.lineTo(p2x, p2y);
        ctx.stroke();
        ctx.restore();
      }

      function drawTriangle(x, y, color) {
        const [px, py] = worldToCanvas(x, y);
        const size = canvas.width * 0.018;
        const half = size / 2;
        ctx.save();
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(px, py - half);
        ctx.lineTo(px + half, py + half);
        ctx.lineTo(px - half, py + half);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }

      function drawDashedCircle(x, y, color) {
        const [px, py] = worldToCanvas(x, y);
        const r = canvas.width * 0.015;
        ctx.save();
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.arc(px, py, r, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      }

      function drawRobotAround(vectors, bearingDeg) {
        const size = aroundCanvas.width;
        aroundCtx.clearRect(0, 0, size, size);
        if (!vectors || vectors.length === 0) return;
        const cx = size / 2;
        const cy = size / 2;

        const angle = (bearingDeg || 0) * Math.PI / 180.0
        const cosA = Math.cos(angle);
        const sinA = Math.sin(angle);

        let maxAbs = 0.0;
        for (const v of vectors) {
          maxAbs = Math.max(maxAbs, Math.abs(v.x), Math.abs(v.y));
        }
        if (maxAbs <= 0.000001) maxAbs = 1.0;
        const scale = (size * 0.4) / maxAbs;

        aroundCtx.save();
        aroundCtx.fillStyle = COLORS.aroundCenter;
        aroundCtx.beginPath();
        aroundCtx.arc(cx, cy, 3, 0, Math.PI * 2);
        aroundCtx.fill();

        aroundCtx.strokeStyle = COLORS.aroundVector;
        aroundCtx.lineWidth = 2;
        const polyPoints = [];
        for (const v of vectors) {
          const rx = v.x * cosA - v.y * sinA;
          const ry = v.x * sinA + v.y * cosA;
          const ex = cx + rx * scale;
          const ey = cy - ry * scale;
          polyPoints.push([ex, ey]);
          aroundCtx.beginPath();
          aroundCtx.moveTo(cx, cy);
          aroundCtx.lineTo(ex, ey);
          aroundCtx.stroke();
        }

        if (polyPoints.length > 1) {
          aroundCtx.strokeStyle = "#e4572e";
          aroundCtx.lineWidth = 2;
          aroundCtx.beginPath();
          aroundCtx.moveTo(polyPoints[0][0], polyPoints[0][1]);
          for (let i = 1; i < polyPoints.length; i += 1) {
            aroundCtx.lineTo(polyPoints[i][0], polyPoints[i][1]);
          }
          aroundCtx.lineTo(polyPoints[0][0], polyPoints[0][1]);
          aroundCtx.stroke();
        }
        aroundCtx.restore();
      }

      async function fetchJson(url) {
        try {
          const res = await fetch(url, { cache: "no-store" });
          if (!res.ok) return null;
          return await res.json();
        } catch (e) {
          return null;
        }
      }

      function makeVisibleKey(ball) {
        return `${ball.x.toFixed(4)},${ball.y.toFixed(4)}`;
      }

      async function tick() {
        const [current, balls, visible, obstacles, waypoints, robotAround] = await Promise.all([
          fetchJson("/data/current"),
          fetchJson("/data/balls"),
          fetchJson("/data/visible"),
          fetchJson("/data/obstacles"),
          fetchJson("/data/waypoints"),
          fetchJson("/data/robot-around")
        ]);

        const robot = current && current.current ? current.current : null;
        const ballList = balls && balls.balls ? balls.balls : [];
        const visibleList = visible && visible.visible ? visible.visible : [];
        const obstacleList = obstacles && obstacles.obstacles ? obstacles.obstacles : [];
        const dynamic = waypoints && waypoints.dynamic ? waypoints.dynamic : null;
        const stack = waypoints && waypoints.stack ? waypoints.stack : null;
        const aroundVectors = robotAround && robotAround.vectors ? robotAround.vectors : [];

        drawField();

        const visibleSet = new Set(visibleList.map(makeVisibleKey));
        for (const b of ballList) {
          const highlight = visibleSet.has(makeVisibleKey(b));
          drawBall(b.x, b.y, b.type, highlight);
        }

        for (const o of obstacleList) {
          drawObstacle(o.x, o.y, o.bearing);
        }

        if (dynamic) {
          if (robot) {
            drawLine(robot.x, robot.y, dynamic.x, dynamic.y, COLORS.waypointLine, 2);
          }
          if (stack) {
            drawDashedCircle(dynamic.x, dynamic.y, COLORS.waypointMuted);
          } else {
            drawTriangle(dynamic.x, dynamic.y, COLORS.dynamic);
          }

          if (stack) {
            drawLine(dynamic.x, dynamic.y, stack.x, stack.y, COLORS.waypointLine, 2);
            drawTriangle(stack.x, stack.y, COLORS.stack);
          }
        }

        if (robot) {
          drawRobot(robot.x, robot.y, robot.bearing);
        }

        drawRobotAround(aroundVectors, robot ? robot.bearing : 0);

        robotStat.textContent = robot
          ? `Robot: (${robot.x.toFixed(2)}, ${robot.y.toFixed(2)}) ${robot.bearing !== null ? robot.bearing.toFixed(1) + "Â°" : ""}`
          : "Robot: --";
        ballStat.textContent = `Balls: ${ballList.length}`;
        visibleStat.textContent = `Visible: ${visibleList.length}`;
        obsStat.textContent = `Obstacles: ${obstacleList.length}`;
      }

      setInterval(tick, 120);
      tick();
    </script>
  </body>
</html>
