<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Field Viewer</title>
    <style>
      :root {
        --bg: #f3f0e7;
        --bg-2: #e7ecef;
        --ink: #1f1f1f;
        --accent: #e4572e;
        --accent-2: #1d7d7a;
        --muted: #7a7a7a;
        --visible: #00DF6C;
        --metal: #000000;
        --ping: #e4572e;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family: "IBM Plex Sans", "Helvetica Neue", Arial, sans-serif;
        color: var(--ink);
        background: radial-gradient(circle at 20% 20%, var(--bg), var(--bg-2));
        min-height: 100vh;
        display: grid;
        place-items: center;
      }
      .wrap {
        width: min(1100px, 96vw);
        display: grid;
        grid-template-columns: 1fr 320px;
        gap: 20px;
      }
      .radar-panel {
        width: min(1100px, 96vw);
        margin-top: 18px;
        padding: 16px;
        display: grid;
        justify-items: center;
      }
      .panel {
        background: rgba(255, 255, 255, 0.65);
        border: 1px solid rgba(0, 0, 0, 0.08);
        border-radius: 16px;
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.08);
        backdrop-filter: blur(6px);
      }
      .canvas-panel {
        padding: 16px;
      }
      .hud {
        padding: 18px 16px;
      }
      h1 {
        margin: 0 0 10px 0;
        font-size: 22px;
        letter-spacing: 0.4px;
      }
      .stat {
        font-size: 13px;
        color: var(--muted);
        margin: 8px 0;
      }
      .legend {
        margin-top: 14px;
        font-size: 13px;
      }
      .legend div {
        display: flex;
        align-items: center;
        gap: 8px;
        margin: 6px 0;
      }
      .chip {
        width: 14px;
        height: 14px;
        border-radius: 4px;
      }
      canvas {
        width: 100%;
        aspect-ratio: 1 / 1;
        display: block;
        border-radius: 12px;
        background:
          linear-gradient(90deg, rgba(0,0,0,0.04) 1px, transparent 1px),
          linear-gradient(0deg, rgba(0,0,0,0.04) 1px, transparent 1px);
        background-size: 10% 10%;
      }
      .note {
        margin-top: 12px;
        font-size: 12px;
        color: var(--muted);
      }
      .around-wrap {
        margin-top: 18px;
        display: grid;
        justify-items: center;
      }
      .radar-wrap {
        width: 100%;
        display: grid;
        display: grid;
        justify-items: center;
      }
      .radar-title {
        margin-top: 6px;
        font-size: 12px;
        color: var(--muted);
        letter-spacing: 0.3px;
        text-transform: uppercase;
      }
      .radar-legend {
        margin-top: 10px;
        display: grid;
        grid-template-columns: repeat(4, minmax(0, 1fr));
        gap: 8px 12px;
        font-size: 12px;
        color: var(--muted);
        width: min(1000px, 100%);
      }
      .radar-legend div {
        display: flex;
        align-items: center;
        gap: 6px;
        justify-content: center;
      }
      .around-title {
        margin-top: 6px;
        font-size: 12px;
        color: var(--muted);
        letter-spacing: 0.3px;
        text-transform: uppercase;
      }
      #around {
        width: 100%;
        max-width: 220px;
        aspect-ratio: 1 / 1;
        border: 2px solid rgba(31, 31, 31, 0.5);
        border-radius: 10px;
        background: rgba(255, 255, 255, 0.5);
      }
      #radarHistory {
        width: 100%;
        max-width: 1000px;
        height: 160px;
        border: 2px solid rgba(31, 31, 31, 0.45);
        border-radius: 10px;
        background: rgba(255, 255, 255, 0.6);
      }
      @media (max-width: 900px) {
        .wrap {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="panel canvas-panel">
        <canvas id="field" width="800" height="800"></canvas>
      </div>
      <div class="panel hud">
        <h1>Field Viewer</h1>
        <div class="stat" id="robotStat">Robot: --</div>
        <div class="stat" id="ballStat">Balls: --</div>
        <div class="stat" id="visibleStat">Visible: --</div>
        <div class="stat" id="obsStat">Obstacles: --</div>
        <div class="stat" id="modeStat">Mode: --</div>
        <div class="stat" id="collisionAvoidingStat">Collision Avoiding: --</div>
        <div class="stat" id="randomSeedStat">Random Seed: --</div>
        <div class="stat" id="collisionCounterStat">Collision Counter: --</div>
        <div class="stat" id="lastBallTakenStat">Last Ball Taken: --</div>
        <div class="legend">
          <div><span class="chip" style="background: var(--accent)"></span> Robot Front</div>
          <div><span class="chip" style="background: var(--accent-2)"></span> Robot Rear</div>
          <div><span class="chip" style="background: var(--ping)"></span> Ping</div>
          <div><span class="chip" style="background: var(--metal)"></span> Metal</div>
          <div><span class="chip" style="background: var(--visible)"></span> Visible Highlight</div>
        </div>
        <div class="note">Range: x,y in [-1, 1] meters</div>
        <div class="around-wrap">
          <canvas id="around" width="220" height="220"></canvas>
          <div class="around-title">robot around</div>
        </div>
      </div>
    </div>
    <div class="panel radar-panel">
      <div class="radar-wrap">
        <canvas id="radarHistory" width="1000" height="160"></canvas>
        <div class="radar-title">radar last 2s</div>
        <div class="radar-legend">
          <div><span class="chip" style="background: #e4572e"></span> Front</div>
          <div><span class="chip" style="background: #3d5a80"></span> Right</div>
          <div><span class="chip" style="background: #1d7d7a"></span> Left</div>
          <div><span class="chip" style="background: #6c757d"></span> Rear</div>
        </div>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("field");
      const ctx = canvas.getContext("2d");
      const aroundCanvas = document.getElementById("around");
      const aroundCtx = aroundCanvas.getContext("2d");
      const radarCanvas = document.getElementById("radarHistory");
      const radarCtx = radarCanvas.getContext("2d");

      const robotStat = document.getElementById("robotStat");
      const ballStat = document.getElementById("ballStat");
      const visibleStat = document.getElementById("visibleStat");
      const obsStat = document.getElementById("obsStat");
      const modeStat = document.getElementById("modeStat");
      const collisionAvoidingStat = document.getElementById("collisionAvoidingStat");
      const randomSeedStat = document.getElementById("randomSeedStat");
      const collisionCounterStat = document.getElementById("collisionCounterStat");
      const lastBallTakenStat = document.getElementById("lastBallTakenStat");

      const COLORS = {
        robot: "#e4572e",
        robotFront: "#1d7d7a",
        ping: "#e4572e",
        metal: "#000000",
        visible: "#00DF6C",
        obstacle: "#212529",
        dynamic: "#e4572e",
        stack: "#1d7d7a",
        waypointLine: "rgba(0, 0, 0, 0.35)",
        waypointMuted: "#7a7a7a",
        aroundBox: "rgba(31, 31, 31, 0.5)",
        aroundVector: "#c7c7c7",
        aroundCenter: "#1f1f1f",
        radarFront: "#e4572e",
        radarRight: "#3d5a80",
        radarLeft: "#1d7d7a",
        radarRear: "#6c757d"
      };

      const RADAR_WINDOW_SEC = 2.0;
      const RADAR_MIN = -0.1;
      const RADAR_MAX = 0.9;

      function worldToCanvas(x, y) {
        const size = canvas.width;
        const px = ((x + 1) / 2) * size;
        const py = size - ((y + 1) / 2) * size;
        return [px, py];
      }

      function drawField() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        ctx.strokeStyle = "rgba(0,0,0,0.6)";
        ctx.lineWidth = 2;
        ctx.strokeRect(0, 0, canvas.width, canvas.height);
        ctx.restore();
      }

      function drawRobot(x, y, bearingDeg) {
        const [px, py] = worldToCanvas(x, y);
        const size = canvas.width * 0.1; // 0.2m in a 2m field
        const half = size / 2;
        const angle = (bearingDeg || 0) * Math.PI / 180.0 + Math.PI // Rotate to point upwards

        ctx.save();
        ctx.translate(px, py);
        ctx.rotate(-angle);
        ctx.fillStyle = COLORS.robot;
        ctx.fillRect(-half, -half, size, size);

        ctx.fillStyle = COLORS.robotFront;
        ctx.fillRect(0, -half, half, size);

        ctx.restore();
      }

      function drawObstacle(x, y, bearingDeg) {
        const [px, py] = worldToCanvas(x, y);
        const size = canvas.width * 0.1; // 0.2m in a 2m field
        const half = size / 2;
        const angle = (bearingDeg || 0) * Math.PI / 180.0;

        ctx.save();
        ctx.translate(px, py);
        ctx.rotate(-angle);
        ctx.fillStyle = COLORS.obstacle;
        ctx.globalAlpha = 0.85;
        ctx.fillRect(-half, -half, size, size);
        ctx.restore();
      }

      function drawBall(x, y, typ, highlight) {
        const [px, py] = worldToCanvas(x, y);
        const isMetal = String(typ || "").toUpperCase() === "METAL";
        const diameterMeters = isMetal ? 0.02 : 0.04;
        const radiusMeters = diameterMeters * 0.5;
        const r = radiusMeters * (canvas.width / 2);
        ctx.save();
        ctx.beginPath();
        ctx.arc(px, py, r, 0, Math.PI * 2);
        ctx.fillStyle = isMetal ? COLORS.metal : COLORS.ping;
        ctx.fill();

        if (highlight) {
          ctx.strokeStyle = COLORS.visible;
          ctx.lineWidth = 3;
          ctx.stroke();
        }
        ctx.restore();
      }

      function drawLine(x1, y1, x2, y2, color, width) {
        const [p1x, p1y] = worldToCanvas(x1, y1);
        const [p2x, p2y] = worldToCanvas(x2, y2);
        ctx.save();
        ctx.strokeStyle = color;
        ctx.lineWidth = width;
        ctx.beginPath();
        ctx.moveTo(p1x, p1y);
        ctx.lineTo(p2x, p2y);
        ctx.stroke();
        ctx.restore();
      }

      function drawTriangle(x, y, color) {
        const [px, py] = worldToCanvas(x, y);
        const size = canvas.width * 0.018;
        const half = size / 2;
        ctx.save();
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(px, py - half);
        ctx.lineTo(px + half, py + half);
        ctx.lineTo(px - half, py + half);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }

      function drawTileSeenOverlay(tiles) {
        if (!tiles || tiles.length === 0) return;

        for (const t of tiles) {
          if (!t || typeof t.value !== "number" || Math.abs(t.value) < 1e-12) {
            continue;
          }

          const x1 = t.x - 0.0125;
          const x2 = t.x + 0.0125;
          const y1 = t.y - 0.0125;
          const y2 = t.y + 0.0125;

          const [px1, py1] = worldToCanvas(x1, y2);
          const [px2, py2] = worldToCanvas(x2, y1);
          const left = Math.min(px1, px2);
          const top = Math.min(py1, py2);
          const width = Math.abs(px2 - px1);
          const height = Math.abs(py2 - py1);

          ctx.save();
          ctx.fillStyle = "rgba(0, 223, 108, 0.7)";
          ctx.fillRect(left, top, width, height);
          ctx.restore();
        }
      }

      function drawUnseenTileOverlay(unseenTiles, unseenRegionTiles) {
        const drawSquares = (tiles, halfSize) => {
          if (!tiles || tiles.length === 0) return;

          for (const t of tiles) {
            if (!t || typeof t.value !== "number" || t.value <= 0) {
              continue;
            }

            const alpha = Math.max(0, Math.min(1, t.value / 60.0));
            if (alpha <= 0) {
              continue;
            }

            const x1 = t.x - halfSize;
            const x2 = t.x + halfSize;
            const y1 = t.y - halfSize;
            const y2 = t.y + halfSize;

            const [px1, py1] = worldToCanvas(x1, y2);
            const [px2, py2] = worldToCanvas(x2, y1);
            const left = Math.min(px1, px2);
            const top = Math.min(py1, py2);
            const width = Math.abs(px2 - px1);
            const height = Math.abs(py2 - py1);

            ctx.save();
            ctx.fillStyle = `rgba(135, 206, 235, ${alpha})`;
            ctx.fillRect(left, top, width, height);
            ctx.restore();
          }
        };

        drawSquares(unseenRegionTiles, 0.05);
        // drawSquares(unseenTiles, 0.025);
      }

      function drawBallTileMemoryOverlay(tiles) {
        if (!tiles || tiles.length === 0) return;

        for (const t of tiles) {
          if (!t || typeof t.value !== "number") {
            continue;
          }

          const [px, py] = worldToCanvas(t.x - 0.025, t.y + 0.025);
          const valueText = Math.abs(t.value - Math.round(t.value)) < 1e-9
            ? String(Math.round(t.value))
            : t.value.toFixed(2);

          ctx.save();
          ctx.fillStyle = "rgba(0, 0, 0, 0.25)";
          ctx.font = "10px IBM Plex Sans, Helvetica Neue, Arial, sans-serif";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(valueText, px, py);
          ctx.restore();
        }
      }

      function drawBallTileMemoryDots(tiles) {
        if (!tiles || tiles.length === 0) return;

        const outerRadius = canvas.width * 0.009;
        const innerRadius = outerRadius * 0.45;
        for (const t of tiles) {
          if (!t || typeof t.value !== "number" || t.value <= 0) {
            continue;
          }

          const [px, py] = worldToCanvas(t.x, t.y);

          ctx.save();
          ctx.beginPath();
          for (let i = 0; i < 10; i += 1) {
            const angle = -Math.PI / 2 + i * (Math.PI / 5);
            const radius = i % 2 === 0 ? outerRadius : innerRadius;
            const x = px + Math.cos(angle) * radius;
            const y = py + Math.sin(angle) * radius;
            if (i === 0) {
              ctx.moveTo(x, y);
            } else {
              ctx.lineTo(x, y);
            }
          }
          ctx.closePath();
          ctx.fillStyle = "rgb(255, 0, 0)";
          ctx.fill();
          ctx.restore();
        }
      }

      function drawDashedCircle(x, y, color) {
        const [px, py] = worldToCanvas(x, y);
        const r = canvas.width * 0.015;
        ctx.save();
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.arc(px, py, r, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      }

      function drawRobotAround(vectors, bearingDeg) {
        const size = aroundCanvas.width;
        aroundCtx.clearRect(0, 0, size, size);
        if (!vectors || vectors.length === 0) return;
        const cx = size / 2;
        const cy = size / 2;

        const angle = (bearingDeg || 0) * Math.PI / 180.0
        const cosA = Math.cos(angle);
        const sinA = Math.sin(angle);

        let maxAbs = 0.0;
        for (const v of vectors) {
          maxAbs = Math.max(maxAbs, Math.abs(v.x), Math.abs(v.y));
        }
        if (maxAbs <= 0.000001) maxAbs = 1.0;
        const scale = (size * 0.4) / maxAbs;

        aroundCtx.save();
        aroundCtx.fillStyle = COLORS.aroundCenter;
        aroundCtx.beginPath();
        aroundCtx.arc(cx, cy, 3, 0, Math.PI * 2);
        aroundCtx.fill();

        aroundCtx.strokeStyle = COLORS.aroundVector;
        aroundCtx.lineWidth = 2;
        const polyPoints = [];
        for (const v of vectors) {
          const rx = v.x * cosA - v.y * sinA;
          const ry = v.x * sinA + v.y * cosA;
          const ex = cx + rx * scale;
          const ey = cy - ry * scale;
          polyPoints.push([ex, ey]);
          aroundCtx.beginPath();
          aroundCtx.moveTo(cx, cy);
          aroundCtx.lineTo(ex, ey);
          aroundCtx.stroke();
        }

        if (polyPoints.length > 1) {
          aroundCtx.strokeStyle = "#35c759";
          aroundCtx.lineWidth = 2;
          aroundCtx.beginPath();
          aroundCtx.moveTo(polyPoints[0][0], polyPoints[0][1]);
          for (let i = 1; i < polyPoints.length; i += 1) {
            aroundCtx.lineTo(polyPoints[i][0], polyPoints[i][1]);
          }
          aroundCtx.lineTo(polyPoints[0][0], polyPoints[0][1]);
          aroundCtx.stroke();
        }

        aroundCtx.save();
        aroundCtx.strokeStyle = "#e4572e";
        aroundCtx.lineWidth = 2;
        aroundCtx.beginPath();
        aroundCtx.arc(cx, cy, 0.05 * scale, 0, Math.PI * 2);
        aroundCtx.stroke();
        aroundCtx.restore();
        aroundCtx.restore();
      }

      function drawRadarHistory(history) {
        const w = radarCanvas.width;
        const h = radarCanvas.height;
        radarCtx.clearRect(0, 0, w, h);
        if (!history || history.length === 0) return;

        const lastTime = history[history.length - 1].t;
        const cutoff = lastTime - RADAR_WINDOW_SEC;
        const windowed = history.filter((p) => p.t >= cutoff);
        if (windowed.length === 0) return;

        const pad = 8;
        const plotW = w - pad * 2;
        const plotH = h - pad * 2;

        const xFor = (t) => pad + ((t - cutoff) / RADAR_WINDOW_SEC) * plotW;
        const yFor = (v) => pad + (1 - (v - RADAR_MIN) / (RADAR_MAX - RADAR_MIN)) * plotH;

        radarCtx.save();
        radarCtx.strokeStyle = "rgba(0,0,0,0.15)";
        radarCtx.lineWidth = 1;
        radarCtx.strokeRect(pad, pad, plotW, plotH);
        radarCtx.restore();

        // Draw boundary lines at 0 and 0.8
        radarCtx.save();
        radarCtx.strokeStyle = "rgba(0,0,0,0.3)";
        radarCtx.lineWidth = 1.5;
        radarCtx.setLineDash([5, 3]);
        
        const y0 = yFor(0);
        radarCtx.beginPath();
        radarCtx.moveTo(pad, y0);
        radarCtx.lineTo(pad + plotW, y0);
        radarCtx.stroke();
        
        const y08 = yFor(0.8);
        radarCtx.beginPath();
        radarCtx.moveTo(pad, y08);
        radarCtx.lineTo(pad + plotW, y08);
        radarCtx.stroke();
        radarCtx.restore();

        const series = [
          { key: "front", color: COLORS.radarFront },
          { key: "right", color: COLORS.radarRight },
          { key: "left", color: COLORS.radarLeft },
          { key: "rear", color: COLORS.radarRear }
        ];

        for (const s of series) {
          radarCtx.save();
          radarCtx.strokeStyle = s.color;
          radarCtx.lineWidth = 2;
          radarCtx.beginPath();
          windowed.forEach((p, idx) => {
            const x = xFor(p.t);
            const y = yFor(p[s.key]);
            if (idx === 0) {
              radarCtx.moveTo(x, y);
            } else {
              radarCtx.lineTo(x, y);
            }
          });
          radarCtx.stroke();
          radarCtx.restore();
        }
      }

      async function fetchJson(url) {
        try {
          const res = await fetch(url, { cache: "no-store" });
          if (!res.ok) return null;
          return await res.json();
        } catch (e) {
          return null;
        }
      }

      function makeVisibleKey(ball) {
        return `${ball.x.toFixed(4)},${ball.y.toFixed(4)}`;
      }

      async function tick() {
        const [current, balls, visible, obstacles, waypoints, robotAround, radarHistory, tileSeenTime, ballTileMemory, unseenTileMemory, unseenRegions, textStatus] = await Promise.all([
          fetchJson("/data/current"),
          fetchJson("/data/balls"),
          fetchJson("/data/visible"),
          fetchJson("/data/obstacles"),
          fetchJson("/data/waypoints"),
          fetchJson("/data/robot-around"),
          fetchJson("/data/radar-history"),
          fetchJson("/data/tile-seen-time"),
          fetchJson("/data/ball-tile-memory"),
          fetchJson("/data/unseen-tile-memory"),
          fetchJson("/data/unseen-regions"),
          fetchJson("/data/text-status")
        ]);

        const robot = current && current.current ? current.current : null;
        const ballList = balls && balls.balls ? balls.balls : [];
        const visibleList = visible && visible.visible ? visible.visible : [];
        const obstacleList = obstacles && obstacles.obstacles ? obstacles.obstacles : [];
        const dynamic = waypoints && waypoints.dynamic ? waypoints.dynamic : null;
        const stack = waypoints && waypoints.stack ? waypoints.stack : null;
        const aroundVectors = robotAround && robotAround.vectors ? robotAround.vectors : [];
        const radarSeries = radarHistory && radarHistory.history ? radarHistory.history : [];
        const tileSeenList = tileSeenTime && tileSeenTime.tiles ? tileSeenTime.tiles : [];
        const ballTileMemoryList = ballTileMemory && ballTileMemory.tiles ? ballTileMemory.tiles : [];
        const unseenTileMemoryList = unseenTileMemory && unseenTileMemory.tiles ? unseenTileMemory.tiles : [];
        const unseenRegionsList = unseenRegions && unseenRegions.tiles ? unseenRegions.tiles : [];

        drawField();
        drawUnseenTileOverlay(unseenTileMemoryList, unseenRegionsList);
        drawTileSeenOverlay(tileSeenList);
        drawBallTileMemoryDots(ballTileMemoryList);
        drawBallTileMemoryOverlay(tileSeenList);

        const visibleSet = new Set(visibleList.map(makeVisibleKey));
        for (const b of ballList) {
          const highlight = visibleSet.has(makeVisibleKey(b));
          drawBall(b.x, b.y, b.type, highlight);
        }

        for (const o of obstacleList) {
          drawObstacle(o.x, o.y, o.bearing);
        }

        if (dynamic) {
          if (robot) {
            drawLine(robot.x, robot.y, dynamic.x, dynamic.y, COLORS.waypointLine, 2);
          }
          if (stack) {
            drawDashedCircle(dynamic.x, dynamic.y, COLORS.waypointMuted);
          } else {
            drawTriangle(dynamic.x, dynamic.y, COLORS.dynamic);
          }

          if (stack) {
            drawLine(dynamic.x, dynamic.y, stack.x, stack.y, COLORS.waypointLine, 2);
            drawTriangle(stack.x, stack.y, COLORS.stack);
          }
        }

        if (robot) {
          drawRobot(robot.x, robot.y, robot.bearing);
        }

        drawRobotAround(aroundVectors, robot ? robot.bearing : 0);
        drawRadarHistory(radarSeries);

        robotStat.textContent = robot
          ? `Robot: (${robot.x.toFixed(2)}, ${robot.y.toFixed(2)}) ${robot.bearing !== null ? robot.bearing.toFixed(1) + "Â°" : ""}`
          : "Robot: --";
        ballStat.textContent = `Balls: ${ballList.length}`;
        visibleStat.textContent = `Visible: ${visibleList.length}`;
        obsStat.textContent = `Obstacles: ${obstacleList.length}`;
        modeStat.textContent = `Mode: ${textStatus && textStatus.mode ? textStatus.mode : "--"}`;
        collisionAvoidingStat.textContent = `Collision Avoiding: ${textStatus && textStatus.collision_avoiding ? textStatus.collision_avoiding : "--"}`;
        randomSeedStat.textContent = `Random Seed: ${textStatus && textStatus.random_seed ? textStatus.random_seed : "--"}`;
        collisionCounterStat.textContent = `Collision Counter: ${textStatus && textStatus.collision_counter ? textStatus.collision_counter : "--"}`;
        lastBallTakenStat.textContent = `Last Ball Taken: ${textStatus && textStatus.last_ball_taken ? textStatus.last_ball_taken : "--"}`;
      }

      setInterval(tick, 120);
      tick();
    </script>
  </body>
</html>
